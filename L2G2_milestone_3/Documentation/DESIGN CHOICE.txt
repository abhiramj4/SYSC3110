DESIGN CHOICE
-------------

We continued to structure our project based on a SYSC 2004 assignment that one of our memebrs had done where he had to make a Chess Game. We decided to use the JavaFX library for all our GUI needs since it is newer and has more features and is easier to use (we think so at least). What's cool is we were able to take our existing Board class and have it inherit the JavaFX GridPane. Since board was already a grid, this worked out perfectly. The Square class also extended the JavaFX Button. After doing this, most of the game logic from our text-based application was automatically transferred. We used a BorderPane layout for our main window allowing us to have a gameboard in the center, the plantcards on top and the next turn button on the right. For the next submission we have space for more objects on the screen. Our model is the Board class, Game being our view and the action listeners are the controllers. When someone clicks on something, the action listeners are triggered which alert the gameboard (Board class) and that in turn updates the GUI (Game class). Other than that most of our design with respect to project structure and game logic is basically identical to our previous submission.



Previous Design Choice Explanation:
We structured our project based on a SYSC 2004 Assignment that one of our members had done where he made a text-based (eventually GUI) Chess game. Certain aspects and project structure were taken from there such as the Coordinate/Square/Board classes, and a few method concepts. We originally used an Observer/Observable pattern but we realized it would be more efficient if we were to create our own listener interface that zombies and plants implement. Zombies and plants both extend Entity and they each have their own children which are the different types of plants/zombies. We figured this would be the most efficient way to implement the entities since instantiating a Sunflower for example can simply be done with new Sunflower() with no extra parameters needed. GameListener has one method right now called Update which is what updates all the entities at different times with different arguments allowing us to have the entities interact and do what they're supposed to do. We have two uses of enumerations where we needed to define certain types. Even though we only have one level right now, we decided to pass information about each level in the form of a JSON object. When we have dozens of levels to make, this would be very easy and efficient. The rest of our code is in the Game class which handles the running of the game, the menu, the displaying of the board, etc. For now, we think that this is the best way to design this game, however we do want to continue trying to make our code more efficient and consider more test scenarios to perfect our project. Once we start implementing the GUI, certain aspects of our project structure/design will change anyways. Enjoy the game, and good luck!